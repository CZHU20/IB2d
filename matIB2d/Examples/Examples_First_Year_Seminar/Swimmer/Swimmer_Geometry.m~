%-------------------------------------------------------------------------------------------------------------------%
%
% IB2d is an Immersed Boundary Code (IB) for solving fully coupled non-linear 
% 	fluid-structure interaction models. This version of the code is based off of
%	Peskin's Immersed Boundary Method Paper in Acta Numerica, 2002.
%
% Author: Nicholas A. Battista
% Email:  nick.battista@unc.edu
% Date Created: May 27th, 2015
% Institution: UNC-CH
%
% This code is capable of creating Lagrangian Structures using:
% 	1. Springs
% 	2. Beams (*torsional springs)
% 	3. Target Points
%	4. Muscle-Model (combined Force-Length-Velocity model, "HIll+(Length-Tension)")
%
% One is able to update those Lagrangian Structure parameters, e.g., spring constants, resting %%	lengths, etc
% 
% There are a number of built in Examples, mostly used for teaching purposes. 
% 
% If you would like us to add a specific muscle model, please let Nick (nick.battista@unc.edu) know.
%
%--------------------------------------------------------------------------------------------------------------------%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% FUNCTION: creates the JELLYFISH-EXAMPLE geometry and prints associated input files
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function Swimmer_Geometry()

% FLUID GRID PARAMETERS %
L = 8;                              % Length of computational domain (m)
N = 256;                            % # of Cartesian grid meshwidths
dx = L/N;                           % Cartesian mesh width (m)

% Construct Geometry
[xLag,yLag,ds] = give_Me_Immsersed_Boundary_Geometry(N,L);
plot(xLag,yLag,'*'); hold on;

% Translate Geometry
xLag = xLag + L/2;
yLag = yLag + L/4;
plot(xLag,yLag,'r*'); hold on;
  
% NAMING CONVENTION FOR SIMULATION 
struct_name = 'swimmer';      % structure name


%
% PRINT INPUT FILES (.vertex, .spring, .beam, etc) %
%

% print vertices
print_Lagrangian_Vertices(xLag,yLag,struct_name);

% print springs
k_Spring = 5*1.2750000000000000e+07;        % spring constant (Newton)
print_Lagrangian_Springs(xLag,k_Spring,ds,struct_name);

% print beams
k_Beam = 500*1.0363359375000002e+10;   % beam stiffness constant (Newton m^2)
print_Lagrangian_nonInv_Beams(xLag,yLag,k_Beam,struct_name);




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% FUNCTION: prints VERTEX points to a file called rubberband.vertex
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function print_Lagrangian_Vertices(xLag,yLag,struct_name)

    N = length(xLag);

    vertex_fid = fopen([struct_name '.vertex'], 'w');

    fprintf(vertex_fid, '%d\n', N );

    %Loops over all Lagrangian Pts.
    for s = 1:N
        X_v = xLag(s);
        Y_v = yLag(s);
        fprintf(vertex_fid, '%1.16e %1.16e\n', X_v, Y_v);
    end

    fclose(vertex_fid); 

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% FUNCTION: prints SPRING points to a file called rubberband.spring
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function print_Lagrangian_Springs(xLag,k_Spring,ds_Rest,struct_name)

    N = length(xLag);

    spring_fid = fopen([struct_name '.spring'], 'w');

    fprintf(spring_fid, '%d\n', N-1 );

    %spring_force = kappa_spring*ds/(ds^2);

    % SPRINGS BETWEEN VERTICES ON RHS
    for s = 1:N-1
        fprintf(spring_fid, '%d %d %1.16e %1.16e\n', s, s+1, k_Spring, ds_Rest);  
    end
    
    
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% FUNCTION: prints BEAM (NON-INVARIANT) points to a file called rubberband.nonInv_beam
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function print_Lagrangian_nonInv_Beams(xLag,yLag,k_Beam,struct_name)

    % k_Beam: beam stiffness
    % Cx/Cy:  beam curvatures in x/y respestively
    
    N = length(xLag); % NOTE: Total number of beams = Number of Total Lag Pts. - 2

    beam_fid = fopen([struct_name '.nonInv_beam'], 'w');

    fprintf(beam_fid, '%d\n', N-2 );

    % beam_force = kappa_beam*ds/(ds^4)
    
    %BEAMS BETWEEN VERTICES ON RHS
    for s = 1:N-2

        Cx = xLag(s) - 2*xLag(s+1) + xLag(s+2);
        Cy = yLag(s) - 2*yLag(s+1) + yLag(s+2);
        fprintf(beam_fid, '%d %d %d %1.16e %1.16e %1.16e\n', s,s+1,s+2, k_Beam, Cx, Cy);  
 
    end
    

    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% FUNCTION: creates the Lagrangian structure geometry
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [xLag,yLag,ds] = give_Me_Immsersed_Boundary_Geometry(N,L)

ds = L/(2*N);

% Straight Portion %
xStraight = 0:ds:L/10;
yStraight = zeros(1,length(xStraight));

% Curved Portion %

tol = 1e-5;    % error tolerance
n = 1;         % counting for array
xC(n) = 0;     % first x-value at (0,-b)
yC(n) = 0;     % first y-value at (0,-b)
tprev = xC(1); % initial x-value
pow = 3;       % power to create curve

while tprev <= L/10;

    n = n+1;
    tnext = tprev + ds/2; %Guess for next angle value
    tfar = 3*tnext;

    %initiating guess for bisection-algorithm
    xn = tnext;
    yn = tnext^pow;
    errSign = ( ds - sqrt( (xn-xC(n-1))^2 + (yn-yC(n-1))^2 ) );
    err = abs(errSign);

    %Bisection algorithm to make points equally spaced
    while ( err > tol )

        if errSign < 0
            tfar = tnext;
            tnext = (tnext+tprev)/2;
        elseif errSign > 0
            tprev = tnext;
            tnext = (tnext+tfar)/2;
        end

        xn = tnext;
        yn = tnext^pow;
        errSign = ( ds - sqrt( (xn-xC(n-1))^2 + (yn-yC(n-1))^2 ) );
        err = abs(errSign);
    end

    xC(n) = xn;    %Store X-value
    yC(n) = yn;    %Store Y-value
    tprev = tnext; %Update X-value

end

% Save Curved Values % 
xCurve = xC + xStraight(end) + ds;
yCurve = yC;

yCurve2 = -yC;

xLag = [xStraight xCurve]; xLag = xLag + 0.7*L;
yLag = [yStraight yCurve]; yLag = yLag + 0.5*L;

yLag2 

plot(xLag,yLag,'*'); hold on; 
axis([0 L 0 L]); 
pause();



% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% % Write out the beam information
%  beam_fid = fopen([mesh_name num2str(N) '.beam'], 'w');
%  
%  fprintf(beam_fid, '%d\n', npts-3);
%  
%  %right side of bell
%  for q = 0:npts_circ-1
%  for s = 0:(ceil(npts_bell/2)-3)
%     C1 = xb(s+1)+xb(s+3)-2*xb(s+2); 
%     C2 = zb(s+1)+zb(s+3)-2*zb(s+2); 
%     fprintf(beam_fid, '%d %d %d %1.16e %1.16e %1.16e\n', q*npts_circ+s, q*npts_circ+s+1, q*npts_circ+s+2, kappa_beam*ds/(ds^4), C1, C2);
%  end
%  
%  %top of bell
%     s=ceil(npts_bell/2);
%     C1 = xb(s+1)+xb(2)-2*xb(1); 
%     C2 = zb(s+1)+zb(2)-2*zb(1); 
%     fprintf(beam_fid, '%d %d %d %1.16e %1.16e %1.16e\n', q*npts_circ+s, q*npts_circ+0, q*npts_circ+1, kappa_beam*ds/(ds^4), C1, C2);
%     s=ceil(npts_bell/2)+1;
%     C1 = xb(s+1)+xb(1)-2*xb(s); 
%     C2 = zb(s+1)+zb(1)-2*zb(s); 
%     fprintf(beam_fid, '%d %d %d %1.16e %1.16e %1.16e\n', q*npts_circ+s, q*npts_circ+s-1, q*npts_circ+0, kappa_beam*ds/(ds^4), C1, C2);
%  
%  %left side of bell   
%  for s = ceil((npts_bell/2)+2):npts_bell-2
%     C1 = xb(s+1)+xb(s-1)-2*xb(s); 
%     C2 = zb(s+1)+zb(s-1)-2*zb(s); 
%     fprintf(beam_fid, '%d %d %d %1.16e %1.16e %1.16e\n', q*npts_circ+s, q*npts_circ+s-1, q*npts_circ+s-2, kappa_beam*ds/(ds^4), C1, C2);
%  end
%  end
% % 
% % 
%  fclose(beam_fid);
% 
